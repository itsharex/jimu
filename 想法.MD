---
updated: 2019-12-30 11:00:00
<br/>
函数编写的时候如何利用上下文呢？<br>是像 mars 项目一样，显式地利用上下文吗？
<br>函数是无状态和普适的，比如我一个函数是：`String foo(String message)`如果有 Context 和流程的概念，我就需要确定这个 message 参数是怎么来的。
message 上面肯定要有一个表达式，去定义这个 message 的来源，那这个函数基本上就不是普适的了，因为它的来源就是固定的了。

---
update：2023年03月20日10:28:59<br/>
FlowContext 作为固定的参数传入的 Service 中，并且改名为 ServiceContext，这样就不需要做 parse 操作了。这里参考了李智慧的框架设计。
---
update 2023年03月20日17:51:38
<br/>
将 Executor 的能力拆分到 Dispatcher 上，由它进行调度，下发任务到 Executor 执行。Executor 负责任务的执行以及结果的上报。

---
update 2023年03月21日18:05:28
<br/>
想不太明白 Executor 和 Dispatcher 之间的依赖关系怎么制定。Dispatcher 调度任务给 Executor，Executor 汇报任务给 Dispatcher，这样的话容易出现循环依赖，需要搞一个抽象层还是搞两个队列用来解耦吗？
<br/>
需要参考一下 Conductor 的设计。
Conductor 的任务时定时拉取的，通过 TCP 的方式。<br/>拉取任务之后，将任务放到线程池执行，根据执行结果上报到具体的调度器上。<br/>定时拉取任务也引入了信号量的概念，避免拉取过来很多任务没有办法执行，导致整个 worker 崩溃。
相当于信号量一直在传递，当执行结束或者执行异常时，操作信号量。<br/>
然后拉取线程根据信号量的多少来决定是否拉取任务。<br>
回到上面的问题，Executor 只是负责执行，Dispatcher 只是负责调度，还缺了一个角色，就是 Worker。Worker 负责拉取任务、上报任务。<br/>
可以用它做中间层的抽象使用。

---
update 2023年03月22日10:09:47
<br/>
调度的决定权在谁手里，是 Dispatcher 还是 Worker？<br/>
Dispatcher 负责调度，Worker 负责执行，这样的话，Worker 就需要知道 Dispatcher 的调度策略，这样就会导致 Worker 和 Dispatcher 之间的耦合度很高，不利于扩展。<br/>
那这样的话，Worker 只是负责向 Dispatcher 获取任务，传递给 Dispatcher 任务类型标识，Dispatcher 根据标识来决定调度策略，然后将任务下发给 Worker。<br/>
Worker 这样就具有专一性了，某一类型的 Worker 只负责某一个类型的任务执行。<br/>
