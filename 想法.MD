# 整体设计的每天想法。
---
updated 2019-12-30 11:00:00
<br/>
函数编写的时候如何利用上下文呢？<br>是像 mars 项目一样，显式地利用上下文吗？
<br>函数是无状态和普适的，比如我一个函数是：`String foo(String message)`如果有 Context 和流程的概念，我就需要确定这个 message 参数是怎么来的。
message 上面肯定要有一个表达式，去定义这个 message 的来源，那这个函数基本上就不是普适的了，因为它的来源就是固定的了。
---
update 2023年03月20日10:28:59
<br/>
FlowContext 作为固定的参数传入的 Service 中，并且改名为 ServiceContext，这样就不需要做 parse 操作了。这里参考了李智慧的框架设计。
---
update 2023年03月20日17:51:38
<br/>
将 Executor 的能力拆分到 Dispatcher 上，由它进行调度，下发任务到 Executor 执行。Executor 负责任务的执行以及结果的上报。

---
update 2023年03月21日18:05:28
<br/>
想不太明白 Executor 和 Dispatcher 之间的依赖关系怎么制定。Dispatcher 调度任务给 Executor，Executor 汇报任务给 Dispatcher，这样的话容易出现循环依赖，需要搞一个抽象层还是搞两个队列用来解耦吗？
<br/>
需要参考一下 Conductor 的设计。
Conductor 的任务时定时拉取的，通过 TCP 的方式。<br/>拉取任务之后，将任务放到线程池执行，根据执行结果上报到具体的调度器上。<br/>定时拉取任务也引入了信号量的概念，避免拉取过来很多任务没有办法执行，导致整个 worker 崩溃。
相当于信号量一直在传递，当执行结束或者执行异常时，操作信号量。<br/>
然后拉取线程根据信号量的多少来决定是否拉取任务。<br>
回到上面的问题，Executor 只是负责执行，Dispatcher 只是负责调度，还缺了一个角色，就是 Worker。Worker 负责拉取任务、上报任务。<br/>
可以用它做中间层的抽象使用。

---
update 2023年03月22日10:09:47
<br/>
调度的决定权在谁手里，是 Dispatcher 还是 Worker？<br/>
Dispatcher 负责调度，Worker 负责执行，这样的话，Worker 就需要知道 Dispatcher 的调度策略，这样就会导致 Worker 和 Dispatcher 之间的耦合度很高，不利于扩展。<br/>
那这样的话，Worker 只是负责向 Dispatcher 获取任务，传递给 Dispatcher 任务类型标识，Dispatcher 根据标识来决定调度策略，然后将任务下发给 Worker。<br/>
Worker 这样就具有专一性了，某一类型的 Worker 只负责某一个类型的任务执行。<br/>

-------
update 2023年03月22日10:09:47
<br/>
调度的算法比较复杂，之前想简单了。根据任务类型去拉取任务的时候，要考虑到任务的优先级以及依赖关系。需要参考一下 Conductor 的设计。
Conductor 的 taskType 不是简单的任务类型，具体是什么，需要明天再看看。Conductor 通过非常多的队列以及任务关系完成了整个系统的关联。
它可能是一个 Flow 一个 Redis 队列
-----
update 2023年04月03日10:35:55
<br/>
如何实现任务的顺序调度呢？非常简单，每一个类型的任务放到单独的队列中去，然后 Worker 拉取执行这些任务，当任务完成回 ack 的时候<br/>
由 Dispatcher 根据任务的依赖关系，将下一个任务放到队列中去，这样就实现了任务的顺序调度。<br/>
这样我们还需要定义一个终止任务，当触发到这个任务时，代表整个 workflow 都完成了。<br/>
后面可以加上限流、熔断这些功能。

----
update 2023年04月04日10:39:36
<br/>
标识最后一个任务应该怎么做，本来想着通过类的继承来实现，通过 instanceof 来判断，但是这样的话，有 bug。<br/>
所以我就通过在任务上加一个标识实现，程序自己去填充这个标识，这样会导致 Task 开始慢慢变胖，但感觉也没有什么办法，因为 Task 就是一个富对象。<br/>
如果按照面向对象的方式，也可以，在 Task 上面建立多个配置外挂类。这时暂时通过慢慢加字段属性的方式。